# Q. 전력망을 둘로 나누기
#
# 문제 설명
# n개의 송전탑이 전선을 통해 하나의 트리 형태로 연결되어 있습니다. 당신은 이 전선들 중 하나를 끊어서 현재의 전력망 네트워크를 2개로 분할하려고 합니다. 이때, 두 전력망이 갖게 되는 송전탑의 개수를 최대한 비슷하게 맞추고자 합니다.
#
# 송전탑의 개수 n, 그리고 전선 정보 wires가 매개변수로 주어집니다. 전선들 중 하나를 끊어서 송전탑 개수가 가능한 비슷하도록 두 전력망으로 나누었을 때, 두 전력망이 가지고 있는 송전탑 개수의 차이(절대값)를 return 하도록 solution 함수를 완성해주세요.
#
# 제한사항
# n은 2 이상 100 이하인 자연수입니다.
# wires는 길이가 n-1인 정수형 2차원 배열입니다.
# wires의 각 원소는 [v1, v2] 2개의 자연수로 이루어져 있으며, 이는 전력망의 v1번 송전탑과 v2번 송전탑이 전선으로 연결되어 있다는 것을 의미합니다.
# 1 ≤ v1 < v2 ≤ n 입니다.
# 전력망 네트워크가 하나의 트리 형태가 아닌 경우는 입력으로 주어지지 않습니다.
# 입출력 예
# n	wires	result
# 9	[[1,3],[2,3],[3,4],[4,5],[4,6],[4,7],[7,8],[7,9]]	3
# 4	[[1,2],[2,3],[3,4]]	0
# 7	[[1,2],[2,7],[3,7],[3,4],[4,5],[6,7]]	1
# 입출력 예 설명
# 입출력 예 #1
#
# 다음 그림은 주어진 입력을 해결하는 방법 중 하나를 나타낸 것입니다.
# ex1.png
# 4번과 7번을 연결하는 전선을 끊으면 두 전력망은 각 6개와 3개의 송전탑을 가지며, 이보다 더 비슷한 개수로 전력망을 나눌 수 없습니다.
# 또 다른 방법으로는 3번과 4번을 연결하는 전선을 끊어도 최선의 정답을 도출할 수 있습니다.
# 입출력 예 #2
#
# 다음 그림은 주어진 입력을 해결하는 방법을 나타낸 것입니다.
# ex2.png
# 2번과 3번을 연결하는 전선을 끊으면 두 전력망이 모두 2개의 송전탑을 가지게 되며, 이 방법이 최선입니다.
# 입출력 예 #3
#
# 다음 그림은 주어진 입력을 해결하는 방법을 나타낸 것입니다.
# ex3.png
# 3번과 7번을 연결하는 전선을 끊으면 두 전력망이 각각 4개와 3개의 송전탑을 가지게 되며, 이 방법이 최선입니다.



# <문제분석>
# n 개의 송전탑이 전선을 통해 하나의 트리 형태로 연결되어 있다
# 전선 중 하나 끊어서 현재의 전력망 네트워크를 2개로 분할하려고 한다
# 이 때 두 전력망이 갖게되는 송전탑의 개수를 최대한 비슷하게 맞추고자 한다

# 송전탑 개수 n
# 전선 정보 wires
# 전선 중 하나 끊어서 개수 비슷하도록 2개 만들었을 때
# 송전탑 개수의 차이 return
# n은 2이상 100이하
# wires 는 길이가 n-1 인 정수형 2차원 배열
# [v1, v2] : v1과 v2가 전선으로 연결되어 있다는 것을 의미

# <풀이>
# 어떤 전선을 끊어야 할지 모른다 -> 모든 경우의 수 구하기
# wires 중 하나를 제거한 모든 경우의 수 구하기
# 그 네트워크의 개수 구해서 차이 적은 것을 반환


from collections import deque

def bfs(start, graph, visited):
    count = 1
    queue = deque([start])
    visited[start] = True

    while queue:
        node = queue.popleft()
        for neighbor in graph[node]: # node 에 연결된 neighbor 구해옴
            if not visited[neighbor]:
                visited[neighbor] = True
                queue.append(neighbor)
                count += 1
    return count

def solution(n, wires):
    min_diff = n  # 최대 차이는 n이므로 초기값은 n으로 설정

    for i in range(len(wires)):
        temp_wires = wires[:i] + wires[i + 1:]  # 하나의 간선을 끊음

        # 그래프 구성
        graph = [[] for _ in range(n + 1)]
        for v1, v2 in temp_wires:
            graph[v1].append(v2)
            graph[v2].append(v1)

        visited = [False] * (n + 1)
        count = bfs(1, graph, visited)  # 아무 노드(1번)에서 시작

        diff = abs(count - (n - count)) # 나머지쪽 개수 구하기
        min_diff = min(min_diff, diff)

    return min_diff

# <피드백>
# 전력망의 정보를 그래프 형태로 관리해야 한다

# 전선 정보중 하나를 없앤 나머지 정보들만 가지고 모든 경우의 수를 체크하면 된다
# wires[:i] + wires[i + 1:] 로 i 번째 제외하는 로직으로 처리 가능하다

# 네트워크는 graph(2차원) 로 표현하면 된다
# 송전탑 n 개에 대한 정보이므로
# graph = [[] for _ in range(n + 1)]
# [v1] 에는 v2의 값, [v2] 에는 v1 의 값을 넣어 양방향 정보를 관리

# bfs를 써서 이미 처리한 노드를 제외하면서 연결된 노드의 수를 구할 수 있다
# 따라서 queue 와 visited 이용
# queue 에는 역시 지금 탐색할 곳,
# visited 는 탐색 다했으면 방문한 곳으로 남기는 용

# 한 개 끊었을 때는 2개로 나누어 지거나 안 나누어지거나 이므로
# 끊고 나서 한 쪽 네트워크에 참여했던 노드 수를 알면 다른 쪽 노드 수도 알 수 있다

