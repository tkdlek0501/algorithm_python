# IT 벤처 회사를 운영하고 있는 라이언은 매년 사내 해커톤 대회를 개최하여 우승자에게 상금을 지급하고 있습니다.
# 이번 대회에서는 우승자에게 지급되는 상금을 이전 대회와는 다르게 다음과 같은 방식으로 결정하려고 합니다.
# 해커톤 대회에 참가하는 모든 참가자들에게는 숫자들과 3가지의 연산문자(+, -, *) 만으로 이루어진 연산 수식이 전달되며, 참가자의 미션은 전달받은 수식에 포함된 연산자의 우선순위를 자유롭게 재정의하여 만들 수 있는 가장 큰 숫자를 제출하는 것입니다.
# 단, 연산자의 우선순위를 새로 정의할 때, 같은 순위의 연산자는 없어야 합니다. 즉, + > - > * 또는 - > * > + 등과 같이 연산자 우선순위를 정의할 수 있으나 +,* > - 또는 * > +,-처럼 2개 이상의 연산자가 동일한 순위를 가지도록 연산자 우선순위를 정의할 수는 없습니다. 수식에 포함된 연산자가 2개라면 정의할 수 있는 연산자 우선순위 조합은 2! = 2가지이며, 연산자가 3개라면 3! = 6가지 조합이 가능합니다.
# 만약 계산된 결과가 음수라면 해당 숫자의 절댓값으로 변환하여 제출하며 제출한 숫자가 가장 큰 참가자를 우승자로 선정하며, 우승자가 제출한 숫자를 우승상금으로 지급하게 됩니다.
#
# 예를 들어, 참가자 중 네오가 아래와 같은 수식을 전달받았다고 가정합니다.
#
# "100-200*300-500+20"
#
# 일반적으로 수학 및 전산학에서 약속된 연산자 우선순위에 따르면 더하기와 빼기는 서로 동등하며 곱하기는 더하기, 빼기에 비해 우선순위가 높아 * > +,- 로 우선순위가 정의되어 있습니다.
# 대회 규칙에 따라 + > - > * 또는 - > * > + 등과 같이 연산자 우선순위를 정의할 수 있으나 +,* > - 또는 * > +,- 처럼 2개 이상의 연산자가 동일한 순위를 가지도록 연산자 우선순위를 정의할 수는 없습니다.
# 수식에 연산자가 3개 주어졌으므로 가능한 연산자 우선순위 조합은 3! = 6가지이며, 그 중 + > - > * 로 연산자 우선순위를 정한다면 결괏값은 22,000원이 됩니다.
# 반면에 * > + > - 로 연산자 우선순위를 정한다면 수식의 결괏값은 -60,420 이지만, 규칙에 따라 우승 시 상금은 절댓값인 60,420원이 됩니다.
#
# 참가자에게 주어진 연산 수식이 담긴 문자열 expression이 매개변수로 주어질 때, 우승 시 받을 수 있는 가장 큰 상금 금액을 return 하도록 solution 함수를 완성해주세요.
#
# [제한사항]
# expression은 길이가 3 이상 100 이하인 문자열입니다.
# expression은 공백문자, 괄호문자 없이 오로지 숫자와 3가지의 연산자(+, -, *) 만으로 이루어진 올바른 중위표기법(연산의 두 대상 사이에 연산기호를 사용하는 방식)으로 표현된 연산식입니다. 잘못된 연산식은 입력으로 주어지지 않습니다.
# 즉, "402+-561*"처럼 잘못된 수식은 올바른 중위표기법이 아니므로 주어지지 않습니다.
# expression의 피연산자(operand)는 0 이상 999 이하의 숫자입니다.
# 즉, "100-2145*458+12"처럼 999를 초과하는 피연산자가 포함된 수식은 입력으로 주어지지 않습니다.
# "-56+100"처럼 피연산자가 음수인 수식도 입력으로 주어지지 않습니다.
# expression은 적어도 1개 이상의 연산자를 포함하고 있습니다.
# 연산자 우선순위를 어떻게 적용하더라도, expression의 중간 계산값과 최종 결괏값은 절댓값이 263 - 1 이하가 되도록 입력이 주어집니다.
# 같은 연산자끼리는 앞에 있는 것의 우선순위가 더 높습니다.
# 입출력 예
# expression	result
# "100-200*300-500+20"	60420
# "50*6-3*2"	300
# 입출력 예에 대한 설명
# 입출력 예 #1
# * > + > - 로 연산자 우선순위를 정했을 때, 가장 큰 절댓값을 얻을 수 있습니다.
# 연산 순서는 아래와 같습니다.
# 100-200*300-500+20
# = 100-(200*300)-500+20
# = 100-60000-(500+20)
# = (100-60000)-520
# = (-59900-520)
# = -60420
# 따라서, 우승 시 받을 수 있는 상금은 |-60420| = 60420 입니다.
#
# 입출력 예 #2
# - > * 로 연산자 우선순위를 정했을 때, 가장 큰 절댓값을 얻을 수 있습니다.
# 연산 순서는 아래와 같습니다.(expression에서 + 연산자는 나타나지 않았으므로, 고려할 필요가 없습니다.)
# 50*6-3*2
# = 50*(6-3)*2
# = (50*3)*2
# = 150*2
# = 300
# 따라서, 우승 시 받을 수 있는 상금은 300 입니다.


# <문제분석>
# 숫자들과 3가지의 연산 문자 +, -, * 으로 연산 수식 전달
# 연산자의 우선순위를 자유롭게 재정의하여 만들 수 있는 가장 큰 숫자 제출
# *단 연산자의 우선순위는 2개 이상의 연산자가 동일한 순위를 가지도록 할 수 없다
# *만약 계산된 결과가 음수면 절댓값으로 변환한다
# ex.
# 일반적으로는 곱하기가 우선순위가 높은데
# 무시하고 + > - > * 등으로 정의할 수 있다
# *제한사항
# expression은 길이가 3 이상 100 이하인 문자열
# 공백, 괄호 없이 오로지 숫자와 3가지 연산자만 있다
# 숫자는 음수값으로 주어지지 않고 999를 초과하지 않는다
# 같은 연산자끼리는 앞에 잇는 것의 우선순위가 더 높다
# 입출력 예시를 보면
# 100-200*300-500+20
# = 100-(200*300)-500+20


# <문제풀이>
# 연산자 3개 의 우선 순위를 자유롭게 재정의 하는 것만 가능
# 그래서 절댓값이 가장 높은 결과값을 출력해야 한다
# 어떤 방식이 가장 높은 값을 가지는 지는 판단하기 어려워 보인다 모든 경우의 수를 구해야 한다

# <구현>
import re
from itertools import permutations
def solution(expression):
    answer = 0

    operation_list = []
    if '*' in expression:
        operation_list.append("*")
    if '+' in expression:
        operation_list.append("+")
    if '-' in expression:
        operation_list.append("-")
    operation_permutations = list(permutations(operation_list)) # 집합(순열) 만들기
    # print(operation_permutations)

    expression = re.split("([^0-9])", expression)
    # print("expression : ", expression)
    for operation_permutation in operation_permutations: # 순열들
        expression_copy = expression[:]
        for operator in operation_permutation: # 그 순열내 여러 연산자
            while operator in expression_copy: # 그 연산자가 있는 동안
                op_index = expression_copy.index(operator) # 연산자의 인덱스(위치)

                if expression_copy[op_index] == "*":
                    cal = int(expression_copy[op_index - 1]) * int(expression_copy[op_index + 1])
                elif expression_copy[op_index] == "+":
                    cal = int(expression_copy[op_index - 1]) + int(expression_copy[op_index + 1])
                elif expression_copy[op_index] == "-":
                    cal = int(expression_copy[op_index - 1]) - int(expression_copy[op_index + 1])
                expression_copy[op_index - 1] = cal # 왼쪽 값에 넣어주고
                expression_copy = expression_copy[:op_index] + expression_copy[op_index + 2:] # 연산자와 오른쪽 값 삭제
                # print("expression_copy : ", expression_copy)
        answer = max(answer, abs(int(expression_copy[0])))
    return answer

print(solution(expression="100-200*300-500+20"))
print(solution(expression="50*6-3*2"))