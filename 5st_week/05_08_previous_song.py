# Q. 네오는 자신이 기억한 멜로디를 가지고 방금그곡을 이용해 음악을 찾는다.
# 그런데 라디오 방송에서는 한 음악을 반복해서 재생할 때도 있어서
# 네오가 기억하고 있는 멜로디는 음악 끝부분과 처음 부분이 이어서
# 재생된 멜로디일 수도 있다.
# 반대로, 한 음악을 중간에 끊을 경우 원본 음악에는 네오가 기억한 멜로디가 들어있다 해도
# 그 곡이 네오가 들은 곡이 아닐 수도 있다.
# 그렇기 때문에 네오는 기억한 멜로디를
# 재생 시간과 제공된 악보를 직접 보면서 비교하려고 한다.
# 다음과 같은 가정을 할 때 네오가 찾으려는 음악의 제목을 구하여라.
import math

# 방금그곡 서비스에서는 음악 제목, 재생이 시작되고 끝난 시각, 악보를 제공한다.
# 네오가 기억한 멜로디와 악보에 사용되는 음은 C, C#, D, D#, E, F, F#, G, G#, A, A#, B 12개이다.
# 각 음은 1분에 1개씩 재생된다. 음악은 반드시 처음부터 재생되며 음악 길이보다 재생된 시간이 길 때는 음악이 끊김 없이 처음부터 반복해서 재생된다.
# 음악 길이보다 재생된 시간이 짧을 때는 처음부터 재생 시간만큼만 재생된다.
# 음악이 00:00를 넘겨서까지 재생되는 일은 없다.
# 조건이 일치하는 음악이 여러 개일 때에는 라디오에서 재생된 시간이 제일 긴 음악 제목을 반환한다. 재생된 시간도 같을 경우 먼저 입력된 음악 제목을 반환한다.
# 조건이 일치하는 음악이 없을 때에는 “(None)”을 반환한다.

# 입력 형식
# 입력으로 네오가 기억한 멜로디를 담은 문자열 m과 방송된 곡의 정보를 담고 있는 배열 musicinfos가 주어진다.
#
# m은 음 1개 이상 1439개 이하로 구성되어 있다.
# musicinfos는 100개 이하의 곡 정보를 담고 있는 배열로, 각각의 곡 정보는 음악이 시작한 시각, 끝난 시각, 음악 제목, 악보 정보가 ','로 구분된 문자열이다.
# 음악의 시작 시각과 끝난 시각은 24시간 HH:MM 형식이다.
# 음악 제목은 ',' 이외의 출력 가능한 문자로 표현된 길이 1 이상 64 이하의 문자열이다.
# 악보 정보는 음 1개 이상 1439개 이하로 구성되어 있다.

# 출력 형식
# 조건과 일치하는 음악 제목을 출력한다.

# <문제분석>
# 방금 그곡을 찾는 문제
# 기억하고 있는 멜로디는 음악 끝부분과 처음 부분이 이어서 재생된 멜로디일 수도 있다
# 반대로 한 음악을 중간에 끊을 경우에는 기억한 멜로디가 들어있다해도 그 곡이 아닐 수도 있다
# 기억한 멜로디를 재생 시간과 제공된 악보를 직접 보면서 비교하려고 한다
# 각 음은 1분에 1개씩 재생 + 음악은 반드시 처음부터 재생 + 음악 길이보다 재생된 시간이 길면 끊김없이 처음부터 재생
# 조건이 일치하는 음악이 여러개 일수도 있다 그 때는  재생 시간이 제일 긴 음악 제목을 반환하고, 시간도 동일하면 먼저 입력된 음악 제목을 반환한다
# 입력)
# m 은 음 1개 이상 1439 개 이하로 구성돼있다
# musicinfos는 100개 이하의 곡 정보를 담고 있는 배열로 시작 시간, 끝난 시간, 제목, 악보 가 ','로 구분된 문자열
# 제목은 ',' 이외의 출력 가능한 문자로 표현되어있고 길이 1 이상 64 이하의 문자열
# 악보정보는 음 1개 이상 1439개 이하로 구성
# 네오가 기억한 멜로디와 악보에 사용되는 음은 C, C#, D, D#, E, F, F#, G, G#, A, A#, B 12개

# <문제풀이>
# 기억하고 있는 m 문자열과
# musicinfos의 악보 문자열을 비교해야 하는데
# 시작 시간과 끝 시간이 있다
# => 1분에 1개의 음이라고 했으니까 끝 시간 - 시작 시간 까지 음을 반복해서 쭉 늘어뜨려야 한다
# => 그리고 이걸 m 문자열이 포함되는지 여부로 체크한다?
# + 조건이 일치하는 음악이 여러개라면 재생시간이 가장 긴 음악 제목 반환, 시간도 동일하면 먼저 입력된 음악 제목 반환
# + C와 C# 은 어떻게 구분할지 생각해야 한다

# <구현>


m = "ABCDEFG"
musicinfos = ["12:00,12:14,HELLO,CDEFGAB", "13:00,13:05,WORLD,ABCDEF"]
# "HELLO" 가 출력되어야 합니다.

# #붙은 음 소문자로 전처리
def replace_step(m):
    return m.replace('C#', 'c').replace('D#', 'd').replace('F#', 'f').replace('G#', 'g').replace('A#', 'a')

def solution(m, musicinfos):
    answer = '(None)'
    m = replace_step(m)
    max_play_time = 0 # 가장 긴 시간
    # print("m : ", m)

    for musicinfo in musicinfos:
        start_time, end_time, name, melody = musicinfo.split(",") # ',' 기준으로 split 해서 그 각각의 값을 파이썬에서는 이렇게 담아둘 수 있다

        # 재생시간
        play_time = int(end_time[:2]) * 60 + int(end_time[3:]) - int(start_time[:2]) * 60 - int(start_time[3:])
        # print("play_time : ", play_time)

        # 원본 멜로디도 # 음 전처리
        melody = replace_step(melody)

        # 멜로디를 올림(재생시간 / 멜로디 길이) 한 값으로 반복해주고 재생시간만큼 자르면 된다
        melody_repeated_count = math.ceil(play_time/ len(melody))
        melody_played = (melody * melody_repeated_count)[:play_time]

        # 찾으려고 하는 음 문자열이 재생된 음 문자열에 포함돼있는지
        if m in melody_played and play_time > max_play_time:
            # 조건이 동일한게 여러개라면 시간 비교, 시간도 동일하면 먼저 나온 음악 제목으로
            answer = name
            max_play_time = play_time

    return answer

print(solution(m, musicinfos))