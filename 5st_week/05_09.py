# Q. 장애 대비용 서버 증설 여부를 결정하기 위해 작년 추석 기간인 9월 15일 로그 데이터를 분석한 후 초당 최대 처리량을 계산해보기로 했다.
# 초당 최대 처리량은 요청의 응답 완료 여부에 관계없이 임의 시간부터 1초(=1,000밀리초)간 처리하는 요청의 최대 개수를 의미한다
from os.path import split

# 입력 형식
# solution 함수에 전달되는 lines 배열은 N(1 ≦ N ≦ 2,000)개의 로그 문자열로 되어 있으며, 각 로그 문자열마다 요청에 대한 응답완료시간 S와 처리시간 T가 공백으로 구분되어 있다.
# 응답완료시간 S는 작년 추석인 2016년 9월 15일만 포함하여 고정 길이 2016-09-15 hh:mm:ss.sss 형식으로 되어 있다.
# 처리시간 T는 0.1s, 0.312s, 2s 와 같이 최대 소수점 셋째 자리까지 기록하며 뒤에는 초 단위를 의미하는 s로 끝난다.
# 예를 들어, 로그 문자열 2016-09-15 03:10:33.020 0.011s은 "2016년 9월 15일 오전 3시 10분 33.010초"부터 "2016년 9월 15일 오전 3시 10분 33.020초"까지 "0.011초" 동안 처리된 요청을 의미한다. (처리시간은 시작시간과 끝시간을 포함)
# 서버에는 타임아웃이 3초로 적용되어 있기 때문에 처리시간은 0.001 ≦ T ≦ 3.000이다.
# lines 배열은 응답완료시간 S를 기준으로 오름차순 정렬되어 있다.
#
# 출력 형식
# solution 함수에서는 로그 데이터 lines 배열에 대해 초당 최대 처리량을 리턴한다.
#
# 입출력 예제
# 예제1
# 입력: [
# "2016-09-15 01:00:04.001 2.0s",
# "2016-09-15 01:00:07.000 2s"
# ]
#
# 출력: 1
#
# 예제2
# 입력: [
# "2016-09-15 01:00:04.002 2.0s",
# "2016-09-15 01:00:07.000 2s"
# ]
#
# 출력: 2
#
# 설명: 처리시간은 시작시간과 끝시간을 포함하므로
# 첫 번째 로그는 01:00:02.003 ~ 01:00:04.002에서 2초 동안 처리되었으며,
# 두 번째 로그는 01:00:05.001 ~ 01:00:07.000에서 2초 동안 처리된다.
# 따라서, 첫 번째 로그가 끝나는 시점과 두 번째 로그가 시작하는 시점의 구간인 01:00:04.002 ~ 01:00:05.001 1초 동안 최대 2개가 된다.
#
# 예제3
# 입력: [
# "2016-09-15 20:59:57.421 0.351s",
# "2016-09-15 20:59:58.233 1.181s",
# "2016-09-15 20:59:58.299 0.8s",
# "2016-09-15 20:59:58.688 1.041s",
# "2016-09-15 20:59:59.591 1.412s",
# "2016-09-15 21:00:00.464 1.466s",
# "2016-09-15 21:00:00.741 1.581s",
# "2016-09-15 21:00:00.748 2.31s",
# "2016-09-15 21:00:00.966 0.381s",
# "2016-09-15 21:00:02.066 2.62s"
# ]
#
# 출력: 7
#
# 설명: 아래 타임라인 그림에서 빨간색으로 표시된 1초 각 구간의 처리량을 구해보면 (1)은 4개, (2)는 7개, (3)는 2개임을 알 수 있다. 따라서 초당 최대 처리량은 7이 되며, 동일한 최대 처리량을 갖는 1초 구간은 여러 개 존재할 수 있으므로 이 문제에서는 구간이 아닌 개수만 출력한다.



# <문제분석>
# lines 배열은 1<=N<=2,000 개의 로그 문자열로 돼있다 -> *N^2 까지는 가능하겠다
# 각 로그 문자열마다
# *요청에 대한 응답 완료 시간 : S 과
# *처리시간 : T 가 공백으로 구분되어 있다.
# 처리시간 T는 0.1s, 0.312s, 2s 등 최대 소수점 셋째 자리까지 기록한다
# ex. 로그 2016-09-15 03:10:33.020 0.011s
# 공백 기준으로 응답완료 시간 과 처리 시간을 구분해서 표현하고 있다
# *서버에는 타임아웃이 '3초' 로 적용되어 있어 처리 시간은 0.001 <= T <= 3.000 이다
# lines 배열은 응답완료시간 S 를 기준으로 오름차순(점점 커짐) 정렬돼있다
# *출력에는 lines 배열에 대해 초당 최대 처리량을 리턴해야 한다

# ex.
# ["2016-09-15 01:00:04.002 2.0s",
# "2016-09-15 01:00:07.000 2s"]
# 출력 : 2
# 설명 : 처리 시간은 *'시작시간과 끝시간을 포함'하므로
# 첫번째는 01:00:02.003 ~ 01:00:04.002 2초 동안 처리
# 두번째는 01:00:05.001 ~ 01:00:07.000 2초 동안 처리
# 따라서 첫번째 로그가 끝나는 시점과 두 번째 로그가 시작하는 시점의 구간인
# 01:00:04.002 ~ 01:00:05:001 1초 동안 최대 2개가 된다
# -> *겹치는 시간대를 봐야 몇 개까지 겹치는지 알 수 있다
# 구간을 어떻게 설정 하는 지가 관건

# <문제풀이>
# 매초 겹치는 지 확인 해야 되나? 특정 시작 시점과 끝 시점으로는 판단하기 어렵다?
# 그렇다면 주어진 문자열이 오름차순이니까 맨 처음과 맨 끝의 완료시간을 받아서 계산해야 하나?
# 1초를 어느 시점부터 잴 수 있지? .001, .002 어떤 기준 인지에 따라서 차이가 날텐데
# 그렇다고 밀리초 기준으로 모두 확인해볼 수는 없다..
# @다시, 주어진 그림을 보면 최대 처리량은 로그의 시작점, 끝점이 몰려있는 구간이다
# 요청량이 변하는 시점은 결국 로그가 시작되거나 끝나는 시점이다
# 즉 각 로그들의 시작되는 시점과 끝나는 시점을 기준으로 1초동안 얼마나 많은 로그가 포함되었는가를 파악해야 한다

# <구현>
# * 처리시간은 시작 시간과 끝 시간을 포함
# 9월 15일 하루동안 이니까 9월 15일 값은 필요 없다
# 1. 주어진 문자열들을 for 문 돌면서
# 2. 응답 완료 시간, 응답 시작 시간을 계산해서 배열에 넣어둔다
# -> 포맷 변경 필요, 시간 계산 해야되므로 단위를 ms로 묶자
# 3. 위 배열을 for문 돌면서 1초 구간 내에 주어진 문자열들이 포함되는지 확인한다
# 4. 포함여부는 걸치기만 하면 되니까 끝 시각 >= 시작 기준 and 시작 시각 < 끝 기준

lines = ["2016-09-15 20:59:57.421 0.351s", "2016-09-15 20:59:58.233 1.181s", "2016-09-15 20:59:58.299 0.8s", "2016-09-15 20:59:58.688 1.041s", "2016-09-15 20:59:59.591 1.412s", "2016-09-15 21:00:00.464 1.466s", "2016-09-15 21:00:00.741 1.581s", "2016-09-15 21:00:00.748 2.31s", "2016-09-15 21:00:00.966 0.381s", "2016-09-15 21:00:02.066 2.62s"]
# 7 이 출력되어야 합니다.

# 1초 동안 얼마나 많은 처리량이 있었는지
def get_request_count_during_one_second(time, start_and_end_times):
    request_count = 0
    start_time = time
    end_time = time + 1000 # ms

    for start_and_end_time in start_and_end_times:
        # 끝 시각이 시작 기준 시간 보다 크거나 같고, 시작 시간이 끝 기준 시간보다 작다면
        if start_and_end_time[1] >= start_time and start_and_end_time[0] < end_time:
            request_count += 1

    return request_count

def solution(lines):
    answer = 0
    start_and_end_times = [] # 모든 시작 시각, 끝 시각의 배열
    for line in lines:
        _, time, duration = line.split()
        time_array = time.split(":")
        duration = float(duration.replace('s', '')) * 1000 # ms 단위로 표현
        # print(time_array, duration)
        end_time = (int(time_array[0]) * 3600 + int(time_array[1]) * 60 + float(time_array[2])) * 1000 # ms 단위로 표현
        start_time = end_time - duration + 1 # 처음, 끝 시간 포함이므로 +1 처리 필요
        start_and_end_times.append([start_time, end_time])
        # print(start_and_end_times)

    # 각 로그들의 시작되는 시점과 끝나는 시점을 기준으로 1초동안 얼마나 많은 로그가 포함되는지
    for start_and_end_time in start_and_end_times:
        # get_request_count_during_one_second(start_and_end_time[0], start_and_end_times) #시작시간 기준으로 개수
        # get_request_count_during_one_second(start_and_end_time[1], start_and_end_times) #끝시간 기준으로 개수
        answer = max(answer, get_request_count_during_one_second(start_and_end_time[0], start_and_end_times), get_request_count_during_one_second(start_and_end_time[1], start_and_end_times))
    return answer

print(solution(lines))