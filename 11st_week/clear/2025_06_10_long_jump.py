# Q. 멀리뛰기
# <문제분석>
# 한 번에 1칸 또는 2칸 뛸 수 있다 -> bin?
# 칸의 수 n이 주어질 때 끝에 도달하는 방법이 몇 가지인지 알아내,
# 여기에 1234567 을 나눈 나머지를 return

# <풀이>
# n은 1 이상 2,000 이하 정수
# dp 로 구할 수 있어보인다
# dp[1] = 1 (1 * 1)
# dp[2] = 2 (1 * 2 or 2 * 1)
# dp[3] = 3 (1 * 3, 1 * 1 + 2, 2 * 1 + 1 * 1)

def solution1(n):  # 칸의 수
    dp = [0] * (n + 1)

    dp[1] = 1 % 1234567 # 어차피 1이 나머지가 될 것이기 때문에 굳이 나눌 필요 없다
    if n >= 2:
        dp[2] = 2 % 1234567
    for i in range(3, n + 1):
        dp[i] = (dp[i - 1] + dp[i - 2]) % 1234567

    return dp[n]

def solution(n):
    dp = [0] * (n + 1)  # 0부터 n까지 저장할 배열 생성 // dp[0] 은 사용 안하니까 + 1
    dp[1] = 1  # 첫 번째 값
    if n >= 2:
        dp[2] = 2  # 두 번째 값

    for i in range(3, n + 1): # 3부터 시작해서 n까지
        dp[i] = (dp[i - 1] + dp[i - 2]) % 1234567  # 피보나치 점화식

    return dp[n]

# <피드백>
# 범위가 최대 2000 이라 재귀나 bfs 등으로 탐색할 수 없는 넓은 범위
# 방법의 수를 묻고 있고, 패턴화 시키면 이전 방법의 수의 합이 다음 방법의 수가 됨을 알 수 있음
# 즉 피보나치형 문제라고 볼 수 있다
# dp[n] = dp[n-1] + dp[n-2]