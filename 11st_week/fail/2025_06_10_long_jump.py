# Q. 멀리뛰기

# <문제분석>
# 한 번에 1칸 or 2칸을 뛸 수 있다
# ex.
# 칸이 총 4칸 있다면
# 1칸 x 4
# 1칸 2칸 1칸
# ...
# 5가지 방법

# 멀리뛰기할 칸의 수 n
# 끝에 도달하는 방법이 몇가지인지 알아내서
# 여기에 1234567을 나눈 나머지를 return

# <풀이>
# n 까지 도달하는 모든 방법의 수를 계산
# 1칸 or 2칸 움직이는 2가지 방법만 있음
# +1 하는 것과 +2 하는 것 재귀로 반복
# queue 를 이용해서 현재 위치만 관리?

# from collections import deque
#
# def solution(n):
#     ways = 0  # 방법의 수
#
#     queue = deque([0])  # 현재 위치
#
#     while queue:
#         q = queue.pop()  # 위치 0 부터 시작
#         if q == n:  # n 값에 정확히 도달하면
#             ways += 1
#         elif q < n:  # n 보다 작으면
#             queue.append(q + 1)
#             queue.append(q + 2)
#
#     return ways % 1234567

# <피드백>
# 위처럼 bfs로 풀면 시간 초과
# visisted 로 최소 거리를 구하는 게 아니라서 어울리지 않다
# 또한 n이 2000이라 bfs 가 아닌 dp 로 풀어야 한다

# 1칸 또는 2칸으로 전진하는 방법만 있으니 경우의 수를 구할 수 있다
# dp[n] 은 n 까지 도달하는 경우의 수이고
# dp[1] = 1 은 1까지 도달하는 경우의 수 1개
# dp[2] = 2 는 2까지 도달하는 경우의 수 2개 (1+1, 2)
# dp[3] = dp[1] + dp[2] -> dp[i] = dp[i - 2] + dp[i - 1]
# 위 2개의 방법(점화식)을 가지고 dp[n] 을 구한다

def solution(n):
    dp = [0] * (n + 1)  # 0부터 n까지 저장할 배열 생성 // dp[0] 은 사용 안하니까 + 1
    dp[1] = 1  # 첫 번째 값
    if n >= 2:
        dp[2] = 2  # 두 번째 값

    for i in range(3, n + 1): # 3부터 시작해서 n까지
        dp[i] = (dp[i - 1] + dp[i - 2]) % 1234567  # 피보나치 점화식

    return dp[n]