# Q. 2xn 타일링

# <문제분석>
# 가로 길이 2
# 세로 길이 1
# 직사각형 모양 타일
# 세로 길이가 2이고 가로 길이가 n인 바닥을 가득 채우려고 한다
# 타일을 채우는 방법은
# 1. 타일을 가로로 배치
# 2. 타일을 세로로 배치
# ex. n이 7인 직사각형은
# 그림과 같이 채울 수 있다.
# 세로로 3개 가로로 4개
# 이 직사각형을 채우는 방법의 수를 1,000,000,007으로 나눈 나머지 return
# 가로 길이 n은 60,000 이하의 자연수

# <풀이>
# 2 x n 의 바닥을 채워야 한다
# 하나씩 채워가면서 n에 도달했을 때의 count 를 구해야 한다?
# BFS를 쓰기에는 길이값이 큰데
# 놓을 수 있는 방법을 보면
# 만약 n이 4이면 5가지 방법이 있음
# DP로 구해야겠다
# dp[4] = 5

# 가로길이 3이면 2 * 3
# 세로 가로*2
# 가로*2 세로
# 세로 세로 세로
# dp[3] = 3


# def solution(n):  # 가로의 길이 (세로는 2로 고정)
#     dp = [[] for _ in range(n + 1)]  # 0부터 시작하므로 0 무시
#
#     dp[1] = 1
#     if n > 1:
#         dp[2] = 2
#     if n <= 2:
#         return dp[n]
#
#     for i in range(3, n + 1):
#         dp[i] = dp[i - 1] + dp[i - 2]
#
#     return dp[n] % 1000000007

# <피드백>
# DP 로 푼 것은 다 맞는데 시간 초과 발생
# 이유는 마지막에 큰 값에 대해 연산하는 로직 때문
# -> 중간 연산을 미리 해주어 작은 값 연산을 유지 해줘야 한다

def solution(n):
    dp = [0] * (n + 1)
    dp[1] = 1
    if n > 1:
        dp[2] = 2
    for i in range(3, n + 1): # n이 1 or 2 이면 어차피 돌지 않음
        dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007

    return dp[n]
