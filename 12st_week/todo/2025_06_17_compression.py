# Q. 압축

# <문제분석>
# 길이가 1인 모든 단어를 포함하도록 사전 초기화
# 2. 사전에서 현재 입력과 일치하는 가장 긴 문자열 w 찾기
# w에 해당하는 사전의 색인 번호 출력하고, 입력에서 w 제거
# 입력에서 처리되지 않은 다음 글자가 남아있다면(c), w+c 에 해당하는 단어를 사전에 등록
# 단계 2로 돌아간다

# ex. 입력으로 KAKAO 가 들어온다면
# 1. 사전에는 첫글자 K는 등록되어 있으나, 두 번째 글자까지인 KA는 없으므로
# 첫글자 K에 해당하는 색인 번호 11을 출력하고, 다음 글자인 A를 포함한 KA를 사전에 27번째로 등록
# 두번째 글자 A는 사전에 있으나, 세 번째 글자까지인 AK는 없으므로 A의 색인번호 1을 출력하고 AK를 28번째로 등록
# 세번째 글자에서 시작하는 KA가 사전에 있으므로, KA에 해당하는 색인번호 27을 출력하고, 다음 글자
# O를 포함한 KAO를 29번째로 등록한다
# 마지막으로 처리되지 않은 글자 O에 해당하는 색인 번호 15 출력

# 주어진 문자열을 압축한 후 사전 색인 번호를 배열로 출력

# <풀이>
# 1. A~Z 값을 배열로 사전을 우선 만든다
# 2. 문자열이 들어오면 단어 1개씩 늘려가면서 위 배열에 있는지 확인한다
# 2-1. 없을 때까지 확인해서 인덱스 출력(answer에 추가) 및 사전 추가를 진행한다
# 최대 1000글자

def solution(msg):
    answer = []
    dictionary = {chr(i + 64): i for i in range(1, 27)}  # 'A'~'Z' 초기 사전 (값:인덱스)
    next_index = 27  # 다음 사전 색인 번호
    i = 0

    while i < len(msg):
        w = msg[i] # i 번째 단어
        j = i + 1 # i 번째 다음 인덱스
        # 가능한 가장 긴 문자열 w 찾기
        while j <= len(msg) and msg[i:j] in dictionary:
            w = msg[i:j]
            j += 1

        answer.append(dictionary[w])  # w의 색인 번호 출력

        # w 다음 글자가 있다면 w+c를 사전에 등록
        if j <= len(msg):
            dictionary[msg[i:j]] = next_index
            next_index += 1

        i += len(w)  # w만큼 이동

    return answer

# <피드백>
# 실제 문자를 자르며 진행하지 말고 i, j를 이용해서 잘라오기



# 자료구조는 어렵지 않지만 요구사항이 빡센 구현 문제
# 문자열을 얼마나 잘 다루는지
# 문제에 주어진 압축 과정(1~5)을 실수 없이 처리하는지
